@using Convergence
@using ConvergenceComponents.Components.Styles
@using Microsoft.AspNetCore.Components.Web
@using System.ComponentModel
@using System.Runtime.InteropServices
@using System.Threading
@using CaputCallback = Convergence.IO.EPICS.CA.EventCallbackDelegate.WriteCallback
@inherits WidgetBase
@implements IAsyncDisposable


@if (IsVisible)
{
	<Alarm BorderStat="@BorderStatus" ContentDisabledTooltip="@(ShowTooltip? TooltipText:string.Empty)" IsContentDisabled="@IsDisabled">
		@if (IsMultiLine)
		{
			<Tooltip Text="@(ShowTooltip? TooltipText:string.Empty)">
				<textarea class="text-area @Class"
						  style="--text-input-width:@GetWidth(); --text-input-height:@GetHeight()"
						  disabled="@ShowTooltip"
						  @bind="Text" @bind:event="oninput" @onkeydown="@OnKeyDownAsync" />
			</Tooltip>
		}
		else
		{
			<Tooltip Text="@(ShowTooltip? TooltipText:string.Empty)">
				<div class="text-entry @Class" style="--text-input-width:@GetWidth(); --text-input-height:@GetHeight()">
					<input class="text-input" type="text" disabled="@ShowTooltip" show-units="@GetShowUnits()" @bind="Text" @bind:event="oninput" @onkeydown="@OnKeyDownAsync" />
					@if (GetShowUnits())
					{
						<span class="clf-units" disabled="@ShowUnits">@Units</span>
					}
				</div>
			</Tooltip>
		}
	</Alarm>
}

@code
{
	[Parameter]
	public string Text { get; set; } = string.Empty;
	[Parameter]
	public string Units { get; set; } = string.Empty;
	[Parameter]
	public bool ShowUnits { get; set; } = false;
	[Parameter]
	public bool IsMultiLine { get; set; } = false;
	[Parameter]
	public int Precision { get; set; } = -1;
	[Parameter]
	public bool IsDisabledOnEnter { get; set; } = false;
	[Parameter]
	public bool WaitForAcknowledgement { get; set; } = false;

	private string _previousValue = "";
	private static Convergence.IO.EPICS.CA.EventCallbackDelegate.ConnectCallback? _connectCallbackEvent;

	public void OnConnectionChanged(Convergence.IO.EPICS.CA.ConnectionEventCallbackArgs args)
	{
		SyncContext!.Post( async _ =>
		{
			if (args.op == Convergence.IO.EPICS.CA.ConnectionEventCallbackArgs.CA_OP_CONN_UP)
			{
				BorderStatus = BorderStatus.Connected;
				IsDisabled = false;
				if (DataType == typeof(long))
				{
					nint pData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Convergence.IO.EPICS.CA.DBR_CTRL_LONG)));
					Marshal.StructureToPtr(new Convergence.IO.EPICS.CA.DBR_CTRL_LONG(), pData, false);
					var status = await Convergence.IO.EPICS.CA.Wrapper.CagetControlMetaDataAsync(Name, DataType, pData);
					if (status == EndPointStatus.Okay)
					{
						var meta = Marshal.PtrToStructure<Convergence.IO.EPICS.CA.DBR_CTRL_LONG>(pData);
						Text = meta.value.ToString();
						if (ShowUnits)
							Units = new string(meta.units).TrimEnd('\0');
						else
						{
							Console.WriteLine($"Failed to get control metadata for {Name} with {status}");
						}
					}
					Marshal.FreeHGlobal(pData);
				}
				else if (DataType == typeof(string))
				{
					nint pData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Convergence.IO.EPICS.CA.DBR_STS_STRING)));
					Marshal.StructureToPtr(new Convergence.IO.EPICS.CA.DBR_STS_STRING(), pData, false);
					var status = await Convergence.IO.EPICS.CA.Wrapper.CagetControlMetaDataAsync(Name, DataType, pData);
					if (status == EndPointStatus.Okay)
					{
						var meta = Marshal.PtrToStructure<Convergence.IO.EPICS.CA.DBR_STS_STRING>(pData);
						Text = new string(meta.value).TrimEnd('\0');
					}
					Marshal.FreeHGlobal(pData);
				}
				
			}
			else
			{
				BorderStatus = BorderStatus.NotConnected;
				IsDisabled = true;
			}
			StateHasChanged();
		}, null);
	}

	protected override async Task OnInitializedAsync()
	{
		await base.OnInitializedAsync();
		SyncContext = SynchronizationContext.Current;
		_connectCallbackEvent += OnConnectionChanged;
		
		this.Width = this.Width == 0 ? TextEntryStyle.DEFAULT_WIDTH : this.Width;
		this.Height = this.Height == 0 ? TextEntryStyle.DEFAULT_HEIGHT : this.Height;

		if (Name != string.Empty)
		{
			SyncContext!.Post(async _ =>
			{
				// Attempt a connection
				// Even if the result returns OK, we dont know if the connection was successful until we get
				// a callback which confirms the connection.
				var connectionResult = await Convergence.IO.EPICS.CA.Wrapper.ConnectAsync(Name, DataType, ElementCount, _connectCallbackEvent!);
				StateHasChanged();
			}, null);
		}
	}

	private bool GetShowUnits()
	{
		return (!string.IsNullOrEmpty(Units) && ShowUnits);
	}

	private string GetWidth()
	{
		return Width != 0 ? $"{Width}px" : "var(--clf-text-entry-default-width)";
	}

	private string GetHeight()
	{
		return Height != 0 ? $"{Height}px" : "var(--clf-text-entry-default-height)";
	}

	public async Task OnKeyDownAsync(KeyboardEventArgs e)
	{
		await base.InvokeAsync(() =>
		{
			//only try to write to the PV if Connected and "Enter" key is pressed
			if (BorderStatus == BorderStatus.Connected && (e.Code == "Enter" || e.Code == "NumpadEnter"))
			{
				SyncContext!.Post(async _ =>
				{
					// Do CaPutAsync with a callback to update the value
					await Convergence.IO.EPICS.CA.Wrapper.CaputAsync(Name, Text, typeof(string));
					StateHasChanged();

				}, null);
			}
		});
	}

	public async ValueTask DisposeAsync()
	{
		try
		{
			using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(Convergence.IO.EPICS.CA.ConvergeOnEPICSChannelAccess.EPICS_TIMEOUT_SEC)); // 10-second timeout

			bool disconnected = await Convergence.IO.EPICS.CA.Wrapper.DisconnectAsync(Name).WaitAsync(cts.Token);
			if (SyncContext != null) SyncContext = null;
			if (_connectCallbackEvent != null) _connectCallbackEvent -= OnConnectionChanged;
		}
		catch (OperationCanceledException)
		{
			// Handle timeout
			Console.WriteLine($"Disconnect operation for {Name} timed out.");
		}
		catch (Exception ex)
		{
			// Handle other exceptions
			Console.WriteLine($"Error during disconnect: {ex.Message}");
		}
	}
}